<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Studio Minus Community Gallery</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            font-family: 'Playfair Display', serif;
        }

        .overlay {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            color: white;
            font-size: 1em;
            display: flex;

            flex-direction: row;
            place-content: center;
            gap: 20px;
            text-shadow: black 0 1px 3px;
        }

        .key {
            font-weight: bold;
            margin-right: 0.2em;
        }
    </style>
</head>

<body>
    <div class="overlay">
        <span><span class="key">[Hold mouse button]</span>Look around</span>
        <span><span class="key">[WASD]</span>Move</span>
        <span><span class="key">[SPACE]</span>Zoom</span>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three/build/three.module.min.js",
                "SSRPass": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/SSRPass.js",
                "AdaptiveToneMappingPass": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/AdaptiveToneMappingPass.js",
                "UnrealBloomPass": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/UnrealBloomPass.js",
                "EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/EffectComposer.js",
                "RenderPass": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/RenderPass.js",
                "GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/GLTFLoader.js",
                "RGBELoader": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/RGBELoader.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'GLTFLoader';
        import { RGBELoader } from 'RGBELoader';
        import { EffectComposer } from 'EffectComposer';
        import { RenderPass } from 'RenderPass';
        import { UnrealBloomPass } from 'UnrealBloomPass';
        import { AdaptiveToneMappingPass } from 'AdaptiveToneMappingPass';
        // import { SSRPass } from 'SSRPass';

        const movementSpeed = 5;
        const playerHeight = 1.5;
        const lookSpeed = 0.2;
        const fovs = [80, 30];
        let lastFovTarget = fovs[0];

        const keyStates = {};
        let mouseDown = false;
        let mousePos = { x: 0, y: 0 };
        let previousMousePos = { x: 0, y: 0 };
        let everythingIsLoaded = false;

        const scene = new THREE.Scene();
        const player = new THREE.Group();
        const camera = new THREE.PerspectiveCamera(fovs[0], window.innerWidth / window.innerHeight, 0.1, 1000);
        const clock = new THREE.Clock(true);
        const loader = new GLTFLoader();

        const renderer = new THREE.WebGLRenderer();
        // renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.setSize(window.innerWidth, window.innerHeight);
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        // composer.addPass(new SSRPass({
        //     renderer,
        //     scene,
        //     camera,
        //     width: innerWidth  / 25,
        //     height: innerHeight / 25,
        //     encoding: THREE.sRGBEncoding,
        //     isPerspectiveCamera: true,
        //     groundReflector: null,
        //     selects: null
        // }));
        composer.addPass(new AdaptiveToneMappingPass());
        composer.addPass(new UnrealBloomPass({ x: 256, y: 256 }, 0.3, 1, 0.5));
        document.body.appendChild(renderer.domElement);

        document.addEventListener('mousemove', (e) => { mousePos.x = e.clientX; mousePos.y = e.clientY }, false);
        document.addEventListener('keydown', e => keyStates[e.code] = true);
        document.addEventListener('keyup', e => keyStates[e.code] = false);
        document.addEventListener('mousedown', e => mouseDown = true);
        document.addEventListener('mouseup', e => mouseDown = false);
        window.addEventListener('resize', e => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        let mixer;

        function setup() {
            player.add(camera);
            player.position.x = 0;
            player.position.y = playerHeight;
            player.position.z = -1;
            loader.load('room.glb', (gltf) => {
                scene.add(gltf.scene);
                mixer = new THREE.AnimationMixer(gltf.scene)

                const animationAction = mixer.clipAction(gltf.animations[1])
                animationAction.play();
                console.log("map loaded")

                new RGBELoader().load('studio_small_02_1k.hdr', function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.environment = texture;
                    render();
                    console.log("hdri loaded")
                    everythingIsLoaded = true;
                });
            });
        }

        function update(dt) {
            let mouseDelta = { x: mousePos.x - previousMousePos.x, y: mousePos.y - previousMousePos.y };
            previousMousePos.x = mousePos.x;
            previousMousePos.y = mousePos.y;

            if (mouseDown) {
                player.rotation.y += -mouseDelta.x * dt * lookSpeed;
                camera.rotation.x += -mouseDelta.y * dt * lookSpeed;
            }

            let lookVector = new THREE.Vector3(0, 0, 0);
            camera.getWorldDirection(lookVector);
            lookVector = new THREE.Vector2(lookVector.x, lookVector.z);
            lookVector.normalize();

            lookVector = new THREE.Vector3(lookVector.x, 0, lookVector.y);

            const movementVector = lookVector.multiplyScalar(movementSpeed * dt);

            if (keyStates['KeyW']) {
                player.position.x += movementVector.x;
                player.position.z += movementVector.z;
            }

            if (keyStates['KeyS']) {
                player.position.x -= movementVector.x;
                player.position.z -= movementVector.z;
            }

            if (keyStates['KeyD']) {
                player.position.x += -movementVector.z;
                player.position.z += movementVector.x;
            }

            if (keyStates['KeyA']) {
                player.position.x -= -movementVector.z;
                player.position.z -= movementVector.x;
            }

            if (keyStates['Space']) {
                console.log(camera)
                camera.fov = SmoothApproach(camera.fov, lastFovTarget, fovs[1], 5, dt);
                lastFovTarget = fovs[1];
            } else {
                camera.fov = SmoothApproach(camera.fov, lastFovTarget, fovs[0], 15, dt);
                lastFovTarget = fovs[0];
            }

            camera.updateProjectionMatrix();
        }

        function render(dt) {
            if (everythingIsLoaded)
                mixer.update(dt)
            composer.render(scene, camera);
        }

        function tick() {
            requestAnimationFrame(tick);
            const dt = clock.getDelta();
            update(dt);
            render(dt);
        }
        setup();
        tick();

        function SmoothApproach(pastPosition, pastTargetPosition, targetPosition, speed, deltaTime) {
            let t = deltaTime * speed;
            let v = (targetPosition - pastTargetPosition) / t;
            let f = pastPosition - pastTargetPosition + v;
            let result = targetPosition - v + f * Math.exp(-t);
            if (isNaN(result))
                return pastPosition;
            return result;
        }
    </script>
</body>

</html>