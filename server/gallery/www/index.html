<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Studio Minus Community Gallery</title>
    <base href="/www/" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            font-family: 'Playfair Display', serif;
            background-color: black;
        }

        .overlay {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            color: white;
            font-size: 1.2em;
            display: flex;

            flex-direction: row;
            place-content: center;
            gap: 20px;
            text-shadow: black 0 1px 3px;
        }

        .loaded {
            display: none;
        }

        .error {
            display: none !important;
        }

        .key {
            font-weight: bold;
            margin-right: 0.2em;
        }
    </style>
</head>

<body>
    <div class="loaded overlay">
        <span><span class="key">[Hold mouse button]</span>Look around</span>
        <span><span class="key">[WASD]</span>Move</span>
        <span><span class="key">[SPACE]</span>Zoom</span>
    </div>

    <div class="loading"
        style="position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 100;color: white; font-size: 2em; display: grid; place-items: center;">
        <div style="display: flex; flex-direction: column; place-content: center; text-align: center">
            <span style="font-weight: bold; color: #FF0061">Studio Minus</span>
            <span>Community Gallery</span>
            <span style="opacity: 0.5; font-size: 0.8em">loading...</span>
        </div>
    </div>

    <div class="error"
        style="position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 100;color: red; display: grid; place-items: center;">
        <div style="display: flex; flex-direction: column; place-content: center; text-align: center">
            <span style="font-weight: bold; font-size: 2em; ">ERROR</span>
            <span style="font-size: 1.5em">Everything is broken.</span>
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three/build/three.module.min.js",
                "SSRPass": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/SSRPass.js",
                "AdaptiveToneMappingPass": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/AdaptiveToneMappingPass.js",
                "UnrealBloomPass": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/UnrealBloomPass.js",
                "EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/EffectComposer.js",
                "RenderPass": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/postprocessing/RenderPass.js",
                "GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/GLTFLoader.js",
                "RGBELoader": "https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/loaders/RGBELoader.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'GLTFLoader';
        import { RGBELoader } from 'RGBELoader';
        import { EffectComposer } from 'EffectComposer';
        import { RenderPass } from 'RenderPass';
        import { UnrealBloomPass } from 'UnrealBloomPass';
        import { AdaptiveToneMappingPass } from 'AdaptiveToneMappingPass';
        // import { SSRPass } from 'SSRPass';

        const movementSpeed = 5;
        const playerHeight = 1.5;
        const lookSpeed = 0.2;
        const fovs = [80, 30];
        const renderScale = 0.75;
        let lastFovTarget = fovs[0];
        let loadProgress = 0;

        const keyStates = {};
        let mouseDown = false;
        let mousePos = { x: 0, y: 0 };
        let previousMousePos = { x: 0, y: 0 };
        let everythingIsLoaded = false;

        const scene = new THREE.Scene();
        const player = new THREE.Group();
        const camera = new THREE.PerspectiveCamera(fovs[0], window.innerWidth / window.innerHeight, 0.1, 1000);
        const clock = new THREE.Clock(true);
        const meshLoader = new GLTFLoader();
        const textureLoader = new THREE.TextureLoader();

        const renderer = new THREE.WebGLRenderer();
        renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2;
        renderer.setSize(window.innerWidth * renderScale, window.innerHeight * renderScale);
        renderer.domElement.style.width = '100vw';
        renderer.domElement.style.height = '100vh';
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        // composer.addPass(new SSRPass({
        //     renderer,
        //     scene,
        //     camera,
        //     width: innerWidth  / 25,
        //     height: innerHeight / 25,
        //     encoding: THREE.sRGBEncoding,
        //     isPerspectiveCamera: true,
        //     groundReflector: null,
        //     selects: null
        // }));
        const adaptiveTonemapping = new AdaptiveToneMappingPass(true);
        composer.addPass(adaptiveTonemapping);
        composer.addPass(new UnrealBloomPass({ x: 256, y: 256 }, 0.3, 1, 0.9));
        // composer.addPass(new BrightnessContrastEffect({ brightness: 3 }));
        document.body.appendChild(renderer.domElement);

        adaptiveTonemapping.setAdaptionRate(0.001);
        adaptiveTonemapping.setMinLuminance(0.0005);

        document.addEventListener('mousemove', (e) => { mousePos.x = e.clientX; mousePos.y = e.clientY }, false);
        document.addEventListener('keydown', e => keyStates[e.code] = true);
        document.addEventListener('keyup', e => keyStates[e.code] = false);
        document.addEventListener('mousedown', e => mouseDown = true);
        document.addEventListener('mouseup', e => mouseDown = false);
        window.addEventListener('resize', e => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        let mixer;

        function setup() {
            player.add(camera);
            player.position.x = 0;
            player.position.y = playerHeight;
            player.position.z = 24;

            setTimeout(() => {
                meshLoader.load('TentScene.glb', (gltf) => {
                    textureLoader.load('booms.png', booms => {
                        const mat = gltf.scene.children[5].material;
                        booms.wrapS = THREE.RepeatWrapping;
                        booms.wrapT = THREE.RepeatWrapping;
                        mat.alphaTest = 0.5;
                        mat.alphaMap = booms;
                        mat.transparent = true;
                        mat.texture = booms;
                        mat.needsUpdate = true;
                    });

                    gltf.scene.children[9].children[1].material.emissiveIntensity = 5;
                    gltf.scene.children[9].children[1].material.emissive = new THREE.Color(30.2,30.2,30.2,1);
                    gltf.scene.children[9].children[1].material.needsUpdate = true;

                    getArtworkIds().then(async d => {
                        console.log("art found: ", d);
                        const meshes = gltf.scene.children.filter(m => m.name.startsWith("Art_")).sort((a,b) => (parseInt(a.name.substring(4)) - parseInt(b.name.substring(4))));
                        console.log(meshes)
                        let index = 0;
                        for (const id of d) {
                            let art = await getArtwork(id);
                            let img = await getArtworkImage(art);

                            meshes[index].material.emissive = new THREE.Color(0.2,0.2,0.2,1);
                            meshes[index].material.emissiveMap = img;
                            meshes[index].material.map = img;
                            meshes[index].material.needsUpdate = true;

                            console.log(img);
                            index++;
                        }
                    });

                    scene.add(gltf.scene);
                    console.log("map loaded")

                    console.log(gltf);

                    new RGBELoader().load('enight-small-bright.hdr', (texture) => {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = texture;
                        scene.background = texture;
                        render();
                        console.log("hdri loaded")
                        everythingIsLoaded = true;

                        document.querySelectorAll('.loading').forEach(e => e.remove());
                        document.querySelectorAll('.loaded').forEach(e => e.classList.remove('loaded'));
                    }, p => { loadProgress = (p.loaded / p.total) }, e => {
                        console.error(e);
                        setErrorState(e);
                    });
                }, p => { loadProgress = (p.loaded / p.total) }, e => {
                    console.error(e);
                    setErrorState(e);
                });
            }, 0)
        }

        function setErrorState(e) {
            document.querySelectorAll('.loading').forEach(e => e.remove());
            document.querySelectorAll('.loaded').forEach(e => e.remove());
            document.querySelectorAll('canvas').forEach(e => e.remove());
            document.querySelectorAll('.error').forEach(e => e.classList.remove('error'));
        }

        async function getArtworkIds() {
            let response = await (await fetch('/art')).json();
            return response;
        }

        async function getArtwork(id) {
            let artMeta = await (await fetch(`/art/${id}`)).json();
            return artMeta;
        }

        async function getArtworkImage(artwork) {
            return textureLoader.load('/' + artwork.Src);
        }

        function update(dt) {
            let mouseDelta = { x: mousePos.x - previousMousePos.x, y: mousePos.y - previousMousePos.y };
            previousMousePos.x = mousePos.x;
            previousMousePos.y = mousePos.y;

            if (mouseDown) {
                player.rotation.y += -mouseDelta.x * dt * lookSpeed;
                camera.rotation.x = Math.max(-1, Math.min(1, camera.rotation.x - mouseDelta.y * dt * lookSpeed));
            }

            let lookVector = new THREE.Vector3(0, 0, 0);
            camera.getWorldDirection(lookVector);
            lookVector = new THREE.Vector2(lookVector.x, lookVector.z);
            lookVector.normalize();

            lookVector = new THREE.Vector3(lookVector.x, 0, lookVector.y);

            const movementVector = lookVector.multiplyScalar(movementSpeed * dt);

            if (keyStates['KeyW']) {
                player.position.x += movementVector.x;
                player.position.z += movementVector.z;
            }

            if (keyStates['KeyS']) {
                player.position.x -= movementVector.x;
                player.position.z -= movementVector.z;
            }

            if (keyStates['KeyD']) {
                player.position.x += -movementVector.z;
                player.position.z += movementVector.x;
            }

            if (keyStates['KeyA']) {
                player.position.x -= -movementVector.z;
                player.position.z -= movementVector.x;
            }

            if (keyStates['Space']) {
                camera.fov = SmoothApproach(camera.fov, lastFovTarget, fovs[1], 15, dt);
                lastFovTarget = fovs[1];
            } else {
                camera.fov = SmoothApproach(camera.fov, lastFovTarget, fovs[0], 15, dt);
                lastFovTarget = fovs[0];
            }

            camera.updateProjectionMatrix();
        }

        function render(dt) {
            // if (everythingIsLoaded)
            //     mixer.update(dt)
            composer.render(scene, camera);
        }

        function tick() {
            requestAnimationFrame(tick);
            const dt = clock.getDelta();
            update(dt);
            render(dt);
        }
        setup();
        tick();

        function SmoothApproach(pastPosition, pastTargetPosition, targetPosition, speed, deltaTime) {
            let t = deltaTime * speed;
            let v = (targetPosition - pastTargetPosition) / t;
            let f = pastPosition - pastTargetPosition + v;
            let result = targetPosition - v + f * Math.exp(-t);
            if (isNaN(result))
                return pastPosition;
            return result;
        }
    </script>
</body>

</html>