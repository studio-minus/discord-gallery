<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Studio Minus Community Gallery</title>
    <base href="/www/" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="favicon.png">


    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            font-family: 'Playfair Display', serif;
            background-color: black;
        }

        .overlay {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            color: white;
            font-size: 1.2em;
            display: flex;
            flex-direction: row;
            place-content: center;
            gap: 20px;
            text-shadow: black 0 1px 3px;
        }

        .loaded {
            display: none;
        }

        .error {
            display: none !important;
        }

        .key {
            font-weight: bold;
            margin-right: 0.2em;
        }
    </style>
</head>

<body>
    <div class="loaded overlay">
        <span><span class="key">[Hold mouse button]</span>Look around</span>
        <span><span class="key">[WASD]</span>Move</span>
        <span><span class="key">[SPACE]</span>Zoom</span>
    </div>

    <div class="loading"
        style="position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 100;color: white; font-size: 2em; display: grid; place-items: center;">
        <div style="display: flex; flex-direction: column; place-content: center; text-align: center">
            <span style="font-weight: bold; color: #FF0061">Studio Minus</span>
            <span>Community Gallery</span>
            <span id="state-display" style="opacity: 0.5; font-size: 0.8em">click to enter</span>
        </div>
    </div>

    <div class="error"
        style="position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: 100;color: red; display: grid; place-items: center;">
        <div style="display: flex; flex-direction: column; place-content: center; text-align: center">
            <span style="font-weight: bold; font-size: 2em; ">ERROR</span>
            <span style="font-size: 1.5em">Everything is broken.</span>
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.min.js",
                "EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/postprocessing/EffectComposer.js",
                "RenderPass": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/postprocessing/RenderPass.js",
                "GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/loaders/GLTFLoader.js",
                "RGBELoader": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/loaders/RGBELoader.js",

                "simplexNoise": "https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/+esm"
            }
        }
    </script>

    <script src="utils.js"></script>
    <script src="audio.js"></script>
    <script src="worldSdf.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'GLTFLoader';
        import { RGBELoader } from 'RGBELoader';
        import { EffectComposer } from 'EffectComposer';
        import { RenderPass } from 'RenderPass';
        import { createNoise2D } from 'simplexNoise';

        const movementSpeed = 1;
        const playerHeight = 1.5;
        const lookSpeed = 0.2;
        const fovs = [80, 30];
        const renderScale = 0.75;
        let lastFovTarget = fovs[0];
        let playerVelocity = new THREE.Vector2(0, 0);
        let loadProgress = 0;

        const keyStates = {};
        let mouseDown = false;
        let mousePos = { x: 0, y: 0 };
        let previousMousePos = { x: 0, y: 0 };
        let everythingIsLoaded = false;
        let secondCounter = 0;
        let discObject;
        let gramophoneIsPlaying = false;
        let shouldGramophonePlay = false;
        let canInteractWithGramophone = false;
        let skyfriendObj;
        let showSkyFriend = Math.random() > 0.9995;

        const scene = new THREE.Scene();
        const player = new THREE.Group();
        const camera = new THREE.PerspectiveCamera(fovs[0], window.innerWidth / window.innerHeight, 0.1, 1000);
        const clock = new THREE.Clock(true);
        const meshLoader = new GLTFLoader();
        const textureLoader = new THREE.TextureLoader();
        const noise2D = createNoise2D();

        const renderer = new THREE.WebGLRenderer();
        renderer.toneMappingExposure = 0.3;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.setSize(window.innerWidth * renderScale, window.innerHeight * renderScale);
        renderer.domElement.style.width = '100vw';
        renderer.domElement.style.height = '100vh';
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        document.body.appendChild(renderer.domElement);
        document.addEventListener('mousemove', (e) => { mousePos.x = e.clientX; mousePos.y = e.clientY }, false);
        document.addEventListener('keydown', e => keyStates[e.code] = true);
        document.addEventListener('keyup', e => keyStates[e.code] = false);
        document.addEventListener('mousedown', e => mouseDown = true);
        document.addEventListener('mouseup', e => mouseDown = false);
        window.addEventListener('resize', e => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        async function setup() {
            initaliseAudio();

            player.add(camera);
            player.position.x = 0;
            player.position.y = playerHeight;
            player.position.z = 24;

            setTimeout(async () => {
                meshLoader.load('TentScene.glb', async (gltf) => {
					showSkyFriend |= (keyStates['KeyU'] && keyStates['KeyP'] && keyStates['KeyL']);
                    function setBasicMaterial(obj) {
                        if (obj.isMesh && obj.material && obj.geometry) {
                            let original = obj.material;
                            let map = original.emissiveMap;

                            obj.material = new THREE.MeshBasicMaterial({});
                            obj.material.color = new THREE.Color(1, 1, 1, 1);

                            if (map) {
                                map.encoding = THREE.sRGBEncoding;
                                obj.material.map = map;
                            }

                            original.dispose();
                        }

                        if (obj.children)
                            for (const child of obj.children)
                                setBasicMaterial(child);
                    }

                    setBasicMaterial(gltf.scene);

                    textureLoader.load('/www/cubemap/cubemap.png', texture => {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        const gramophoneMetal = gltf.scene.children.filter((m) => m.name.includes('Gramophone'))[1];
                        gramophoneMetal.material.envMap = texture;
                        gramophoneMetal.material.combine = THREE.MultiplyOperation;
                        gramophoneMetal.material.reflectivity = 0.5;
                    });

                    textureLoader.load('booms.png', booms => {
                        const mat = gltf.scene.children.filter((m) => m.name.includes('Bomen'))[0].material;
                        booms.wrapS = THREE.RepeatWrapping;
                        booms.wrapT = THREE.RepeatWrapping;
                        mat.alphaTest = 0.5;
                        mat.alphaMap = booms;
                        mat.transparent = true;
                        mat.texture = booms;
                        mat.needsUpdate = true;
                    });

                    // disc
                    discObject = gltf.scene.children.filter((m) => m.name.startsWith('Disc'))[0];
                    const discArt = await getMusicDiscArt();
                    gramophoneAudioElem.src = discArt?.AudioData || "sfx/musicless.ogg";
                    textureLoader.load(discArt?.ImageData || "https://i.imgur.com/ohoJC7u.png", img => {
                        img.encoding = THREE.sRGBEncoding;
                        img.flipY = false
                        discObject.material.alphaTest = 0
                        discObject.material.transparent = false
                        discObject.material.color = new THREE.Color(1, 1, 1, 1)
                        discObject.material.map = img
                        discObject.material.needsUpdate = true
                    });

                    // actual artworks
                    getArtworkIds().then(async d => {
                        console.log("art found: ", d);
                        const ezels = gltf.scene.children.filter(m => m.name.startsWith("Art_")).sort((a, b) => (parseInt(a.name.substring(4)) - parseInt(b.name.substring(4))));
                        let i = 0;
                        for (const id of d) {
                            const w = Math.ceil(ezels[i].scale.x * 1024);
                            const h = Math.ceil(ezels[i].scale.z * 1024);
                            let img = await textureLoader.load(`/art/${id}/image/${w}/${h}`);
                            img.encoding = THREE.sRGBEncoding;
                            img.flipY = false;

                            let mat = ezels[i].material;
                            mat.alphaTest = 0.5;
                            mat.transparent = false;
                            mat.color = new THREE.Color(0.9, 0.9, 0.9, 1);
                            mat.map = img;
                            mat.needsUpdate = true;
                            i++;
                            if (i >= ezels.length)
                                break;
                        }
                    }).catch(e => console.error(e));

                    if (showSkyFriend)
                        textureLoader.load("/www/luchtvriend.png", img => {
                            img.encoding = THREE.sRGBEncoding;
                            const quadGeom = new THREE.PlaneGeometry(1, 1);
                            const material = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
                            material.alphaTest = 0
                            material.transparent = true
                            material.color = new THREE.Color(1, 1, 1, 1)
                            material.map = img
                            material.needsUpdate = true
                            skyfriendObj = new THREE.Mesh(quadGeom, material);
                            skyfriendObj.position.set(0, 150, 0);
                            skyfriendObj.rotation.set(90, 0, 0);
                            scene.add(skyfriendObj);
                        });

                    scene.add(gltf.scene);
                    console.log("map loaded")

                    new RGBELoader().load('enight-small-bright.hdr', (texture) => {
                        texture.mapping = THREE.EquirectangularReflectionMapping;
                        scene.environment = texture;
                        scene.background = texture;
                        render();
                        console.log("hdri loaded")
                        everythingIsLoaded = true;

                        document.querySelectorAll('.loading').forEach(e => e.remove());
                        document.querySelectorAll('.loaded').forEach(e => e.classList.remove('loaded'));
                    }, p => { loadProgress = (p.loaded / p.total) }, e => {
                        console.error(e);
                        setErrorState(e);
                    });
                }, p => { loadProgress = (p.loaded / p.total); }, e => {
                    console.error(e);
                    setErrorState(e);
                });
            }, 0)
        }

        function setErrorState(v) {
            document.querySelectorAll('.loading').forEach(e => e.remove());
            document.querySelectorAll('.loaded').forEach(e => e.remove());
            document.querySelectorAll('canvas').forEach(e => e.remove());
            document.querySelectorAll('.error').forEach(e => e.classList.remove('error'));
        }

        async function getArtworkIds() {
            try {
                let response = await (await fetch('/art/images')).json();
                return response;
            } catch (error) {
                return [null, null, null, null, null];
            }
        }

        async function getMusicDiscArt() {
            try {
                let musicdisc = await (await fetch('/art/musicdisc')).json();
                if (!musicdisc)
                    return null;
                return musicdisc;
            } catch (error) {
                return null;
            }
        }

        async function getArtwork(id) {
            try {
                let artMeta = await (await fetch(`/art/${id}`)).json();
                return artMeta;
            } catch (error) {
                return null
            }
        }

        async function getArtworkImage(artwork) {
            try {
                return textureLoader.load('/' + artwork.Src);
            } catch (error) {
                return null;
            }
        }

        function update(dt) {
            secondCounter += dt;
            let mouseDelta = { x: mousePos.x - previousMousePos.x, y: mousePos.y - previousMousePos.y };
            previousMousePos.x = mousePos.x;
            previousMousePos.y = mousePos.y;

            if (mouseDown) {
                player.rotation.y += -mouseDelta.x * dt * lookSpeed;
                camera.rotation.x = Math.max(-1.3, Math.min(1.3, camera.rotation.x - mouseDelta.y * dt * lookSpeed));
            }

            if (discObject && gramophoneAudioElem.src) {
                var closeEnough = discObject.position.distanceTo(player.position) < 1.5;

                if (closeEnough && canInteractWithGramophone) {
                    canInteractWithGramophone = false;
                    shouldGramophonePlay = !shouldGramophonePlay;
                }

                if (!closeEnough)
                    canInteractWithGramophone = true;

                if (gramophoneIsPlaying)
                    discObject.rotation.set(0, discObject.rotation.y + dt * 2, 0);
            }

            if (shouldGramophonePlay != gramophoneIsPlaying) {
                gramophoneIsPlaying = shouldGramophonePlay;
                if (shouldGramophonePlay)
                    gramophoneAudioElem.play();
                else
                    gramophoneAudioElem.pause();
            }

            if (showSkyFriend) {
                let t = (clock.elapsedTime - 5) * 0.2;
                const height = 150;
                let startPos = new THREE.Vector3(500, height, 1000);
                let midPos = new THREE.Vector3(0, height, 15);
                let wavingPos = new THREE.Vector3(noise2D(t * 0.25, 0) * 150, height, noise2D(0, t * 0.25 - 423.534) * 150);
                let endPos = new THREE.Vector3(100, height, 9000);
                let state = Math.floor(t);
                let alpha = t % 1;
                switch (state) {
                    default:
                        skyfriendObj.position.lerp(startPos, 1)
                        break;
                    case 0:
                        skyfriendObj.position.lerpVectors(startPos, midPos, easeOutCubic(alpha))
                        break;
                    case 1:
                        skyfriendObj.position.lerpVectors(midPos, wavingPos, easeInCubic(alpha))
                        break;
                    case 2:
                    case 3:
                    case 4:
                        skyfriendObj.position.lerp(wavingPos, 1)
                        break;
                    case 5:
                        skyfriendObj.position.lerpVectors(wavingPos, endPos, easeInCubic(alpha))
                        break;
                }

                function easeInCubic(x) {
                    return x * x * x;
                }
                function easeOutCubic(x) {
                    return 1 - Math.pow(1 - x, 3);
                }
            }

            let lookVector = new THREE.Vector3(0, 0, 0);
            camera.getWorldDirection(lookVector);
            lookVector = new THREE.Vector2(lookVector.x, lookVector.z);
            lookVector.normalize();

            lookVector = new THREE.Vector3(lookVector.x, 0, lookVector.y);

            const movementVector = lookVector.multiplyScalar(movementSpeed * dt);
            playerVelocity.x = smoothApproach(playerVelocity.x, playerVelocity.x, 0, 45, dt);
            playerVelocity.y = smoothApproach(playerVelocity.y, playerVelocity.y, 0, 45, dt);

            if (keyStates['KeyW']) {
                playerVelocity.x += movementVector.x;
                playerVelocity.y += movementVector.z;
            }

            if (keyStates['KeyS']) {
                playerVelocity.x -= movementVector.x;
                playerVelocity.y -= movementVector.z;
            }

            if (keyStates['KeyD']) {
                playerVelocity.x += -movementVector.z;
                playerVelocity.y += movementVector.x;
            }

            if (keyStates['KeyA']) {
                playerVelocity.x -= -movementVector.z;
                playerVelocity.y -= movementVector.x;
            }

            player.position.x += playerVelocity.x;
            player.position.z += playerVelocity.y;

            let maxIterations = 1000;
            let normal = getNormalForWall({ x: player.position.x, y: player.position.z });
            while (getDistanceFromWall({ x: player.position.x, y: player.position.z }) <= 0.1) {
                player.position.x += normal.x * 0.001;
                player.position.z += normal.y * 0.001;
                if (maxIterations-- <= 0)
                    break;
            }

            if (keyStates['Space']) {
                camera.fov = smoothApproach(camera.fov, lastFovTarget, fovs[1], 15, dt);
                lastFovTarget = fovs[1];
            } else {
                camera.fov = smoothApproach(camera.fov, lastFovTarget, fovs[0], 15, dt);
                lastFovTarget = fovs[0];
            }

            camera.updateProjectionMatrix();
        }

        function render(dt) {
            if (everythingIsLoaded)
                composer.render(scene, camera);
        }

        async function tick() {
            requestAnimationFrame(tick);
            const dt = clock.getDelta();
            if (everythingIsLoaded)
                update(dt);

            let worldPos = new THREE.Vector3();
            camera.getWorldPosition(worldPos);
            let dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            let insideness = Math.min(1, mapRange(5, 0, 1, 0, Math.max(0, 15 - worldPos.length())));

            if (secondCounter > 1) {
                secondCounter = 0;
                if (Math.random() > 0.9) {
                    const bear = await createPointSpeaker(
                        sounds.bear[Math.floor(Math.random() * sounds.bear.length)],
                        8, 0.8, 4, 4, 5);
                    bear.start();
                    bear.addEventListener('ended', () => bear.disconnect());
                }

                if (Math.random() > 0.95) {
                    const creak = await createPointSpeaker(
                        sounds.creaking[Math.floor(Math.random() * sounds.creaking.length)],
                        0, 8, 0, 5, 7);
                    creak.start();
                    creak.addEventListener('ended', () => creak.disconnect());
                }

                if (Math.random() > 0.9) {
                    const cloth = await createPointSpeaker(
                        sounds.cloth[Math.floor(Math.random() * sounds.cloth.length)],
                        0, 5, 0, 3, 15);
                    cloth.start();
                    cloth.addEventListener('ended', () => cloth.disconnect());
                }

                if (Math.random() > 0.9 && worldPos.length() > 40) {
                    const w = await createPointSpeaker("sfx/running.wav",
                        player.position.x + randomRange(-10, 10), 1, player.position.z + randomRange(-10, 10), 4, 15);
                    w.start();
                    w.addEventListener('ended', () => w.disconnect());
                }

                if (Math.random() > 0.95) {
                    const gladiators = await createPointSpeaker(
                        sounds.gladiators[Math.floor(Math.random() * sounds.gladiators.length)],
                        0, 5, -9, 4, 15);
                    gladiators.start();
                    gladiators.addEventListener('ended', () => gladiators.disconnect());
                }

                if (Math.random() > 0.9995) {
                    const wilJeNietHoren = await createPointSpeaker(sounds.wilJeNietHoren, 40, 10, 0, 2, 60);
                    wilJeNietHoren.start();
                    wilJeNietHoren.addEventListener('ended', () => wilJeNietHoren.disconnect());
                }

                if (!crowdSource && insideness > 0.5 && Math.random() > 0.994) {
                    crowdSource = audioCtx.createBufferSource();
                    crowdSource.buffer = await loadAudio(sounds.peopleTalking);
                    const node = setAudioPosition(crowdSource, -12.4, 1.5, 7.8, 2, 50);
                    crowdGainNode = new GainNode(audioCtx);
                    crowdGainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    crowdGainNode.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 2);

                    node.connect(crowdGainNode).connect(audioCtx.destination);
                    crowdSource.start();
                    crowdSource.loop = true;
                }

                if (crowdSource && insideness < 1) {
                    const current = crowdSource;
                    const currentGainNode = crowdGainNode;
                    crowdSource = null;
                    crowdGainNode = null;
                    currentGainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                    setTimeout(() => {
                        current.stop();
                        current.disconnect();
                    }, 0.5 * 1000);
                }
            }

            listener.setPosition(worldPos.x, worldPos.y, worldPos.z);
            listener.setOrientation(dir.x, dir.y, dir.z, 0, 1, 0);

            if (outdoorLowpassNode && outdoorGainNode) {
                outdoorGainNode.gain.value = mapRange(0, 1, 0.3, 0.05, insideness);
                outdoorLowpassNode.frequency.value = mapRange(0, 1, 12000, 2800, insideness);
            }

            if (gramophoneLowpassNode) {
                gramophoneLowpassNode.frequency.value = mapRange(0, 1, 12000, 800, 1 - insideness);
            }
            // console.log(worldPos);
            render(dt);
        }

        let hasInteracted = false;
        window.addEventListener('mousedown', async () => {
            if (hasInteracted)
                return;
            hasInteracted = true;
            document.getElementById('state-display').textContent = 'loading...';
            await setup();
            await tick();
        })


    </script>
</body>

</html>